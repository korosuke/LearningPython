・クロージャ。関数の内部で定義されて、かつ外側の関数のローカル変数を参照してい
る関数。

・BaseException , Exception , ArithmeticError , LookupError , EnvironmentError
は直接発生させることはできない。

・すべての例外の規定クラスはBaseException

・assert文でデバッグ用の例外を発生させる。

・raise文で例外を発生させる。

・__slot__特殊メソッドを用いれば保持するインスタンス変数を制限する事が出来る。

・変数に_をつけると疑似的なプライベート変数になる。

・property。ある属性を外部から参照だけにしたい場合等に用いる。

・スティックメソッド。インスタンスを生成しなくても使えるメソッド。

・クラスメソッド。そのクラスのすべてのインスタンスに影響を与えるメソッド？

・@classmethod , @staticmethodでクラスメソッドやスティックメソッドを実装できる
よ。

・タプル、リスト等の組み込み型も継承できるよ。

・コンテナ型の特殊メソッドいろいろあるので実装する時はリファレンス見ながら行う
事

・オブジェクトが関数として呼ばれたときの挙動を決めるのは__call__特殊メソッド
（この機能を使えばいろいろできそう）

・特殊メソッドを利用する事によって代数演算のカスタマイズを行える。

・%演算子は答えがマイナスになる場合は正数の余りに直してくれる。

・特殊メソッドをちゃんと実装する事によって、クラスのインスタンス同士で演算など
を使用する事ができる。

・特殊メソッド：__*__とアンダーバーで囲まれているメソッドの事。

・getattr,setattr関数はインスタンスの属性をやり取りするのに便利

・__dict__属性を使うとスーパークラスのタプルを得られる。

・インスタンスが所属するクラスを調べる場合は__class__で調べることが可能
しかし、手順がある。
list(instance.__class__.__dict__.items())

・オブジェクトの辞書情報は__dict__を見ればわかるようになっている。

・インスタンスやクラスの属性にアクセスする時は__dict__でアクセスする

・pythonのクラスもインスタンスも辞書型データ
・インスタンスのはローカルの辞書。ある属性にアクセスする場合はローカルの辞書の
データにアクセスし、なければ親の辞書データにアクセスしていく。
その際サクセスする順番はクラス宣言の（）内の親クラスに左から順にアクセスする。

・さすがのスクリプト言語。動的に属性を追加可能。

・コンストラクタは__init__メソッドを用いる（最初の引数は慣例としてself）
・クラスclass実装方法
class ClassName ( SuperClassA , SuperClassB):

・pythonのクラス
情報隠ぺいなし。すべてpublic。
多重軽傷あり
すべてのクラスがサブクラスの作成可能
すべてのメソッドはオーバーライドできる

・decorator　後程紹介

・無名関数。lambda文を用いる。一つの式のみの関数のみ実装可能

・generatorはイテレータを定義する関数。戻り値にはyield文をつける。
→繰り返し処理の条件を独自実装できる

・関数をラップする場合。
内側の関数は外側の変数を使用できる。
外側の関数が内側の変数を使用する場合はnonlocal文で宣言する必要がある。

・末尾再帰は関数内部でしか用いない引数を外部に公開するため末尾再帰関数をラップ
するのが推奨されている。

・末尾再帰。引数に計算結果を含めて行う再帰処理。
例：
def saiki(n):
    return 1 if n==0 else saiki(n-1) * n
def matubi(n, m=1):
    return m if n==0 else matubi(n-1, n*m)

・再帰関数の問題点。Javaでもこれがあるから再
帰的にメソッドを呼び出すのは推奨さ
れていない。
それは再帰呼び出しで発生するメソッドのロードによるメモリの圧迫。
→pythonでは末尾再帰というテクニックで解決できる。

・高階関数。関数を引数や戻り値にとる関数。
→役割の完全分離を実現し、プログラムのモジュール化を促進させる

・再帰関数。自分自身を呼び出す関数。ディレクトリ探索などに用いる

・引数の渡し方が結構ゆるいので体感で覚える事。
・グローバル変数を関数内で変更したい場合はglobal宣言をしてから行う。
・スコープは関数ないのみ
・javascriptほど動的型変換は起きない。というか起きない？
・変数のスコープはifブロックを超えても有効
　おそらくブロック外でも有効。
　javascriptと同じ関数単位のスコープだと思われる。

・ファイルオブジェクトのclosedはメソッドではない
・集合にはsetとfrozensetがある。違いは変更可能か不可か。

・辞書のメンバ関数のview型は辞書内部のデータと連動しているので注意

・辞書は任意の変更不能型のデータとキーで保存するデータ型

・ファイルオブジェクトをイテレータに使用すると
　毎回呼ばれる関数は__next__()メソッド

・ファイルを閉じる時は.close()メソッドを用いる
　何回使用してもよい。
　ファイルを閉じた場合、ファイルが開いている時の処理を行うと
　ValueErrorが送出される

・withブロックの扱い
必ず解放したいリソースがある場合に用いる

・真偽値の文字は頭文字が大文字

・条件代入文もなかなかかっこよい。

・内包表現がかっこよすぎる。for文→if文の順番が大事

・if文の最後にコロンを入れるのを忘れずに

・配列の比較ので注意
型が違う場合はfalse
インデックスの小さい順に比較していき、初めに要素の値が比較のtrueの条件に
あてはあったほうがtrue
比較する要素の値が同じの場合は比較対象が少ないほうが小さいと判断される

・python2から3に変更時にprint関数の仕様が変わり、引数を()でくくらなくてはいけない。
・スライスでも=演算子で代入する事が可能

・配列の型
list tuple str bytes bytearray range

・in演算子でタプル、リスト内のよそを調べられる。

・全てのデータがオブジェクト型だが、
a = 1
b = 1
a is b
の結果がtrueが帰るので単純なオブジェクト型
というわけではなさそう。

・IDLEのショトカ
alt p		履歴戻る
alt n		履歴進む

・変数が同じオブジェクトか比較するにはis

・変更しないデータ
数値　文字列　タプル

・変更可能データ
リスト　辞書

・データはすべてオブジェクト

・基本タプルのほうがリストより高速

・モジュールのインポート
import ライブラリ
form ライブラリ import モジュール

タプル ()
arr(n,m)
・内容の変更が不可
・リストより高速
・タプルでもインデックスにアクセスする時は[]を用いる
・タプルとリストで演算しても動的に変換されない
・list()関数でタプルをリストに変換可能

リスト []
arr[n,m]
・インデックスがnからmまでの部分リストを返す。
・範囲内なら負の記号を使って後ろからアクセスできる。
・部分リスト==スライス
・リスト同士の+*も可能（ただしタプルならタプルの型で返却されることに注意）
・リストは参照値を保持しているので参照先の値を変えるときは注意
・リストの値をコピーしたい場合はlist()関数を用いる
・リストは内容の変更が可能

・

・値の代入（あまり見かけないやり方）
a, b = 2, 9

・文字列にも+*()演算が切る
('word' + ' ') * 4

・文字列は''で囲むのでも""で囲むのでもどちらでもよい。

・/は浮動小数点　//は少数を切り捨てて整数



eclipseで追加のライブラリを入れる場合は環境設定を再度行う。
設定を消して再度オートコンフィグするだけでよい


memo
http://i-saint.hatenablog.com/entry/20101012/1286822888

新版暗号技術入門 秘密の国のアリス

NameError 
値がまだ代入されていない変数を参照しようとすると発生する実行時エラー

isinstance()関数は信頼するのは怪しいかも
aa = True
isinstance(aa, bool)
isinstance(aa, int)
両方Trueになった。

自分でキャストを行う事も可能。
型(キャストしたいデータ)
で可能。

リストに関して
list
list[]
上記の二つは同じ処理をしていない。
上のリストは参照を返却しているが
下のリストはコピーを返却している。

パスを指定する時などは必ずエスケープシーケンスを忘れないこと

特殊クラスとはpythonが呼び出すクラスの事

ジェネレータは関数でありyieldでイテレートする値を返却する。
イテレータクラスはクラスであり__next__メソッドでイテレートする値をreturnで返却する。

re.findall は重なった検索結果を返さない

python の標準のUnitテストは時間も表示されるので性能を確かめたい時にも有利かもしれない

ユニットテストの本当の良さは
テストの責任、担当区分を明確にするということではなく
すべてのテストケースをクリアした時の達成感を得るためだけではなく
リファクタリングを施す自由を与えてくれる事である。

windowsはバックスラッシュでディレクトリの構成を表し、
mac, linuxはフォワードスラッシュでディレクトリの構成を表すが、
pythonではフォワードスラッシュでディレクトリ構成をプラットフォームに依存しないで使う事が出来る。

python3は非asciiのパス名をサポート済み。

python3はローカル内のファイルのみじゃなくネットワーク上のファイルでも開く事が出来る。

ファイルの読み込み。EOFまで読み込んでから再度読み込みを行ってもエラーにはならない。
空文字が返却されるだけ。

再度読み込みたい時はseek()（read()?）メソッドを用いてバイトの位置を指定すればよい。

テキストとしてファイルを開くとread()メソッドは文字単位で扱う事ができる。

バイナリで開くとseek()とread()メソッドで予想外の不一致が起きない。

withとファイルの扱いはコンテキストマネージャを用いて扱っているので
メモリ上の文字列や圧縮されたファイルをメモリに展開してそれらもファイルを扱うように
扱う事が出来る。もちろんwithを用いて安全に扱う事も出来る。

特殊メソッド__enter__()メソッドはwithでコンテクストに入る時に呼ばれる。

特殊メソッド__exit__()メソッドはコンテクストが抜ける時に呼ばれる。

サブジェネレータを混ぜると複数の規則を入れたイテレートを実装できる。


__new__()を実装すると特殊な動きになる。シングルトンを作る時に使えるかも。

P169の拡張モジュールは読んでない→読んだけど頭にはいっていない

pythonがインストールされたフォルダにsiteというファイルがある。サイトとは一つのシステムを表すのでこれで一つのシステムを構築していると思われる。

ハンドラー：ある処理要求に応じて機動されるプログラムの事

ディスパッチャ：処理や資源の割り当てを行うプログラム
